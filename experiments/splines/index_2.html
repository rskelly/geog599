<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Splines</title>
  <meta name="description" content="Splines">
  <meta name="author" content="rob">

  <!--<link rel="stylesheet" href="css/styles.css?v=1.0">-->

  <script src="pc.js"></script>
  <script src="math.js"></script>

  <script>

    const filenames = ['mt_doug_1.txt', 'mt_doug_2.txt', 'mt_doug_3.txt'];
    const pc = new PointCloud();
    
    let drawPc;

    let speed = 4.0;
    let altitude = 100;
    let angle = 25.0;
    let divergence = 0.2;
    let startTime;
    let running = false;
    let alpha = 0.5;
    let binSize = 10.0;

    let animY0 = 0;
    let animY1 = 0;

    const stylePoint = '#aaffaa';

    function update(evt) {
      if(evt)
        evt.preventDefault();
      angle = parseFloat(document.querySelector('#angle').value);
      divergence = parseFloat(document.querySelector('#divergence').value);
      altitude = parseFloat(document.querySelector('#altitude').value);
      speed = parseFloat(document.querySelector('#speed').value);
      alpha = parseFloat(document.querySelector('#alpha').value);
      binSize = parseFloat(document.querySelector('#binSize').value);
    }

    function loadFile(evt) {
      evt.preventDefault();
      pc.load(evt.target.selectedOptions[0].text, (status, msg) => {
        if(status)
          pc.transform();
        document.querySelector('#loading').innerHTML = msg;
      });
    }

    let accum = new PointCloud();
    let tick = 0;
    let pcframe = null;

    function animate(timestamp) {

      tick += 100;

      if(startTime == null) {
        // If this is the first frame, get the time and reschedule.
        startTime = tick;
        requestAnimationFrame(animate);
        return;
      }

      const canv = document.querySelector('#canv');
      const ctx = canv.getContext('2d');

      const screen = new Bounds(0, 0, 0, canv.width, 0, canv.height);
      const t = (tick - startTime) / 1000.0;

      let bounds = pc.bounds.clone();

      // The y (left to right) position is dictated by time.
      let y = t * speed;
      let z = altitude;

      // Create a point to represent the UAV and a point cloud containing
      // only the UAV (for display).
      let uav = new Point(0, y, z);
      let uavpc = new PointCloud([uav]);
      bounds.extend(uav);

      // Get a copy of the point cloud.
      let spc = new PointCloud(pc.points);

      // The slice of the point cloud that will be displayed.
      let slice = pc.sliceYRay(y, z, -angle * Math.PI / 180, divergence * Math.PI / 180);

      // Collect the accumulated points.
      slice.points.forEach(pt => {
        accum.addPoint(pt.clone());
      });

      // Get the convex hull of the accumulated points.
      let hull = accum.getHull(binSize);

      // Get the spline throught the binned heights.
      let spline = getCRSplines(hull.points, alpha);

      let tslice = hull.sliceSeg(y, 4);
      let traj = null;
      if(tslice.length == 4) {
        const t0 = y;
        const t1 = crTJ(t0, tslice[0], tslice[1], alpha);
        const t2 = crTJ(t1, tslice[1], tslice[2], alpha);
        let t = t1 + (t2 - t1) / 2;//(y - tslice[1].y);// / (tslice[2].y - tslice[1].y);
        traj = new PointCloud([catmullRomSplineT(t, tslice[0], tslice[1], tslice[2], tslice[3], alpha)]);
      }

      // Scale point clouds for display.
      slice.scale(screen, bounds);
      spc.scale(screen, bounds);
      uavpc.scale(screen, bounds);
      hull.scale(screen, bounds);
      Point.scale(spline, screen, bounds);
      if(traj)
        traj.scale(screen, bounds);

      ctx.clearRect(0, 0, screen.length, screen.height);

      // Draw the whole cloud lightly.
      ctx.fillStyle = '#dddddd';
      spc.points.forEach(pt => {
        ctx.fillRect(pt.y - 2, screen.zmax - pt.z - 2, 4, 4);
      });

      // Draw the slice points.
      ctx.fillStyle = stylePoint;
      slice.points.forEach(pt => {
        ctx.fillRect(pt.y - 2, screen.zmax - pt.z - 2, 4, 4);
      });

      // Draw the hull points.
      ctx.fillStyle = 'green';
      hull.points.forEach(pt => {
        ctx.fillRect(pt.y - 2, screen.zmax - pt.z - 2, 4, 4);
      });

      // Draw the UAV.
      let uavpt = uavpc.points[0];
      ctx.fillStyle = 'black';
      ctx.fillRect(uavpt.y - 3, screen.zmax - uavpt.z - 3, 6, 6);

      // Draw the height spline
      if(spline.length) {
        ctx.strokeStyle = 'blue';
        ctx.beginPath();
        ctx.moveTo(spline[0].y, spline[0].z);
        for(let i = 1; i < spline.length; ++i)
          ctx.lineTo(spline[i].y, screen.zmax - spline[i].z);
        ctx.stroke();
      }

      if(traj) {
        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'fuscia';
        ctx.fillRect(traj.points[0].y - 3, screen.zmax - traj.points[0].z - 3, 6, 6);
      }

      let lookAhead = new PointCloud([
        new Point(0, y + speed, altitude), 
        new Point(0, y + speed * 2, altitude), 
        new Point(0, y + speed * 3, altitude),
        new Point(0, y + speed * 4, altitude),
        new Point(0, y + speed * 5, altitude),
        new Point(0, y + speed * 6, altitude),
        new Point(0, y + speed * 7, altitude),
        new Point(0, y + speed * 8, altitude),
        new Point(0, y + speed * 9, altitude),
        new Point(0, y + speed * 10, altitude)
      ]);
      lookAhead.scale(screen, bounds);
      ctx.strokeStyle = '#ff00ff22';
      lookAhead.points.forEach(pt => {
        ctx.beginPath();
        ctx.moveTo(pt.y - 2, screen.zmax);
        ctx.lineTo(pt.y - 2, screen.zmin);
        ctx.stroke();
      });

      if(running)
        requestAnimationFrame(animate);
    }

    function start(evt) {
      evt.preventDefault();
      update();
      startTime = null;
      pcframe = null;
      running = true;
      accum.reset();
      requestAnimationFrame(animate);
    }

    function stop(evt) {
      evt.preventDefault();
      running = false;
    }

    function init() {
      let w = document.body.clientWidth;
      let h = 600;
      let canv = document.querySelector('#canv');
      canv.width = w;
      canv.height = h;
      let sel = document.querySelector('#filename');
      sel.add(new Option('', '- Select One -'));
      let i = 0;
      filenames.forEach(f => {
        sel.add(new Option(f, ++i));
      });
      sel.addEventListener('change', loadFile);

      document.querySelector('#altitude').value = altitude;
      document.querySelector('#speed').value = speed;
      document.querySelector('#binSize').value = binSize;
      document.querySelector('#angle').value = angle;
      document.querySelector('#divergence').value = divergence;

    }

  </script>

</head>

<body onload="init();">
  <form>
    <table>
      <tr>
        <td><label for="filename">File</label></td><td><select name="filename" id="filename"></select> <span id="loading"></span></td>
        <td rowspan="7" style="padding-left: 20px;">
          <p>This thing demonstrates what the forward-looking laser will see. Choose a <strong>File</strong> and click <strong>Start</strong>.</p>
          <p>The laser angle is the angle down from horizontal, in degrees. The beam angle is the spread of the beam (nominally 0.2Ëš).</p>
          <p>The light green dots are a point cloud extracted from a real lidar campaign. The laser sweeps back and forth across the swath, but the points are collapsed into a vertical plane, preserving only the y (forward) and z (vertical) dimensions.</p>
          <p>The dark green dots represent the concave hull of the accumulated point cloud. The concave hull is like the convex hull, except the length of a segment is limited by the <strong>Bin Size</strong> attribute. This is similar but not identical to an <em>alpha shape</em>.</p>
          <p>The space between the "laser frontier" and the spot directly below the UAV is the space from which the trajectory must be derived. The length of this space is dynamic and depends on the altitude of the UAV above the surface. There is no accounting for occlusion.</p>
          <p>The black dot is the UAV.</p>
        </td>
      </tr>
      <tr><td><label for="speed">Speed (m/s)</label></td><td><input name="speed" id="speed" value="4" /></td></tr>
      <tr><td><label for="angle">Beam Angle (Down)</label></td><td><input id="angle" name="angle" onchange="update(event);" value="25" /></td></tr>
      <tr><td><label for="divergence">Beam Divergence</label></td><td><input id="divergence" name="divergence" onchange="update(event);" value="0.2" /></td></tr>
      <tr><td><label for="alpha">Alpha</label></td><td><input id="alpha" name="divergence" onchange="update(event);" value="0.75" /></td></tr>
      <tr><td><label for="altitude">Altitude</label></td><td><input id="altitude" name="altitude" onchange="update(event);" value="100" /></td></tr>
      <tr><td><label for="binSize">Bin Size</label></td><td><input id="binSize" name="binSize" onchange="update(event);" value="10" /></td></tr>
      <tr><td colspan="2"><button onclick="start(event);">Start</button> <button onclick="stop(event);">Stop</button></td></tr>
    </table>
  </form>
  <div style="border:1px solid #ccc">
    <canvas id="canv" width="2000" height="600" style="background-color: white"></canvas>
  </div>
</body>
</html>