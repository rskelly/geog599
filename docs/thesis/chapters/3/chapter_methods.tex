\startfirstchapter{Methods}
\label{chapter:Methods}

\section{Equipment}

To prove the concept, it was necessary to equip a UAV with a computer, scanning laser rangefinder and the necessary peripherals and connections.

\subsection{Aircraft}

The platform selected for the experiment was a DJI Matrice 600 hexacopter. Some specifications for the vehicle are given in table \ref{table:djispecs}.

\begin{table}
\begin{center}
\begin{tabular}{ l r }
\hline
Vehicle weight (TB47S batteries) & $\SI{9.1}\kg$ \\ 
Vehicle weight (TB48S batteries) & $\SI{9.6}\kg$ \\
Maximum vehicle weight & $\SI{15.1}\kg$ \\
Maximum pitch angle & $\ang{25}$ \\
Maximum pitch velocity & $\SI{300}{\degree\per\second}$ \\
Maximum yaw velocity & $\SI{150}{\degree\per\second}$ \\
Maximum ascent velocity & $\SI{5}{\metre\per\second}$ \\
Maximum descent velocity & $\SI{3}{\metre\per\second}$ \\
Maximum horizontal velocity & $\SI{18}{\metre\per\second}$ \\
Maximum wind velocity & $\SI{8}{\metre\per\second}$ \\
\hline
\end{tabular}
\end{center}
\caption{DJI Matrice 600 Specifications \cite{DJI2017}.}
\label{table:djispecs}
\end{table}

These constraints may not correspond to the absolute physical limits on vehicle performance, but they do provide a useful guide to the limits that may be imposed by the flight control API, and from these quantities, the dynamic limits of the platform (e.g., maximum thrust) may be inferred.

With the TB47S battery set, the hover time (at $\SI{10}{\metre}$ above sea level and no wind) is given as $\SI{35}{\minute}$ with no load and $\SI{16}{\minute}$ with the maximum $\SI{6}{\kg}$ payload. With the TB48S batteries, the Matrice can hover for $\SI{40}{\minute}$ with no load and $\SI{18}{\minute}$ with a $\SI{5.5}{\kg}$ payload. With these short flight times, especially with the additional weight of the terrain-following system, it is clear that optimizing for battery life is justified \cite{DJI2017}.

\subsection{Computer}

A single Raspberry Pi 3 B+ multi-tasking computer is used to receive inputs from the sensors, produce the point cloud, calculate the and optimize the trajectory, drive the actuators and communicate with the Matrice's control API. The computer runs the standard Raspian Jessie (Debian Linux) operating system. All software for this project is written in the C++ language.

In general, a real-time operating system (RTOS) is preferred for a flight-control role, as it is undesirable for critical processing threads to be pre-empted in favour of non-critical tasks, as can occur in a standard multi-tasking operating system. However, as a proof-of-concept, the Raspberry Pi represents the path of least resistance. Future iterations of the system may be ported to a RTOS.

\subsection{Sensors}

The primary purpose of the sensor package is twofold: first, to generate a point cloud forward of the vehicle as it flies along its trajectory; second, to measure, in real time, its current altitude above the surface. 

The point cloud is generated by a LightWare Optoelectronics SF30/C laser rangefinder. Specifications for this device are given in table \ref{table:lwsf30cspecs}. The Raspberry Pi receives range data directly from SF30/C via RS232 serial communication.

\begin{table}
\begin{center}
\begin{tabular}{l r}
\hline
Maximum range & $> \SI{100}{\metre}$ \\
Maximum pulse frequency & $> \SI{18}{\kHz}$ \\
Weight & $\SI{35}{\g}$ \\
\hline
\end{tabular}
\end{center}
\caption{LightWare SF30/C rangefinder specifications \cite{LightWare2016}.}
\label{table:lwsf30cspecs}
\end{table}

The SF30/C is mounted on a generic (unbranded) P3022 Hall-effect analog angular encoder, which serves as both the bearing for the oscillating laser, and as a means of measuring its current angle. The encoder transmits a voltage relative to the input voltage in proportion to the angle of the shaft, from which the angle in radians can be computed. Specifications for the encoder are given in table \ref{table:encoderspecs}. As the output of the encoder is analog, and a digital reading is required, the voltage is sent to a Texas Instruments ADS1115 analog-to-digital convertor (ADC), mounted on a breakout board manufactured by the Adafruit company. The Raspberry Pi communicates with the ADC via the I2C protocol.

\begin{table}
\begin{center}
\begin{tabular}{l r}
\hline
Resolution & 12 bits ($\SI{360}{\degree} / 4096 \approx \SI{0.088}{\degree}$ \\
Linearity & $0.3\percent$ \\
Operating voltage & $\SI{5}{\volt} \pm \SI{10}{\percent}$ \\
Output voltage & $\SIrange{0}{5}{\volt}$ \\
Operating current & $< \SI{16}{\milli\ampere}$  \\ 
Weight & $\SI{25}{\gram}$ \\
\hline
\end{tabular}
\end{center}
\caption{P3022 Hall-effect encoder specifications.}
\label{table:encoderspecs}
\end{table}

The shaft of the encoder is driven using a four-bar linkage connected to a generic $\SIrange{2.5}{7.5}{\volt}$ geared, brushless direct current (DC) micromotor. The rotational speed of the motor (and thus the scan frequency of the laser) is governed by pulse width modulation (PWM), which can be modified through the flight control computer, and the degree of sweep is governed by the length of the linkage, which must be adjusted manually. The Raspberry Pi has several built-in pins which are used to drive the motors on the carriage via the motor driver board, using an external power supply.

The nadir-aligned laser is a LightWare Optoelectronics SF11/C laser rangefinder, which is similar to the SF30/C, save for a higher nominal range of $\SI{120}{\metre}$ and a maximum pulse rate of $\SI{20}{pulses\per\second}$  \cite{LightWareOptoelectronics2018}. Though the range of the nadir-aligned laser is counterintuitively larger than that of the forward laser, its pulse rate is much lower -- suitable for altitude measurement but not for point cloud generation. Unlike the SF30/C, the SF11/C communicates with the Raspberry Pi via the I2C protocol, as there is only one serial port, and it is required for the high volume of data produced by the SF30/C. In any case, the SF30/C, being an older model does not have I2C capability.

The encoder and nadir-facing laser are rigidly mounted on an aluminum carriage which rotates on the vehicle-aligned y-axis, on a hinge. A stepper motor with a screw-type linear actuator drives the carriage on the axis, allowing it to maintain its orientation on the y-axis. This maintains the alignment of both lasers as the vehicle pitches. The actuator is driven by the Raspberry Pi, through the  same motor driver as the scanner motor.

A miniature inertial measurement unit (IMU), manufactured as a "breakout board" by Pololu Corporation, is used to measure the deviation from vertical of the sensor carriage. The IMU consists of an STMicroelectronics LSM6DS33 accelerometer and gyroscope, as well as a thermometer and magnetometer, which are not used. The output of the IMU is used by the computer to drive the linear actuator to correct the orientation of the carriage. The Raspberry Pi communicates with the IMU via the I2C protocol.


[motor driver board description]



