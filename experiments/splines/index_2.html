<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Splines</title>
  <meta name="description" content="Splines">
  <meta name="author" content="rob">

  <!--<link rel="stylesheet" href="css/styles.css?v=1.0">-->

  <script src="pc.js"></script>
  <script src="math.js"></script>

  <script>

    const filenames = ['mt_doug_1.txt', 'mt_doug_2.txt', 'mt_doug_3.txt'];
    const pc = new PointCloud();
    
    let drawPc;

    let speed = 4.0;
    let altitude = 10;
    let angle = 25.0;
    let divergence = 1.0;
    let startTime;
    let running = false;
    let alpha = 0.5;
    let binSize = 10.0;

    let animY0 = 0;
    let animY1 = 0;

    const stylePoint = '#aaffaa';

    function update(evt) {
      if(evt)
        evt.preventDefault();
      angle = parseFloat(document.querySelector('#angle').value);
      divergence = parseFloat(document.querySelector('#divergence').value);
      altitude = parseFloat(document.querySelector('#altitude').value);
      speed = parseFloat(document.querySelector('#speed').value);
      alpha = parseFloat(document.querySelector('#alpha').value);
      binSize = parseFloat(document.querySelector('#binSize').value);
    }

    function loadFile(evt) {
      evt.preventDefault();
      pc.load(evt.target.selectedOptions[0].text, (status, msg) => {
        if(status)
          pc.transform();
        document.querySelector('#loading').innerHTML = msg;
      });
    }

    let accum = new PointCloud();
    let bins = new Map();
    let finals = new Map();
    let tick = 0;
    let pcframe = null;

    function animate(timestamp) {

      tick += 100;

      if(startTime == null) {
        // If this is the first frame, get the time and reschedule.
        startTime = tick;
        requestAnimationFrame(animate);
        return;
      }

      const canv = document.querySelector('#canv');
      const ctx = canv.getContext('2d');

      const screen = new Bounds(0, 0, 0, canv.width, 0, canv.height);
      const t = (tick - startTime) / 1000.0;

      let bounds = pc.bounds.clone();

      // The y (left to right) position is dictated by time.
      let y = t * speed;
      let z = altitude;

      // Create a point to represent the UAV and a point cloud containing
      // only the UAV (for display).
      let uav = new Point(0, y, z);
      let uavpc = new PointCloud([uav]);
      bounds.extend(uav);

      // Get a copy of the point cloud.
      let spc = new PointCloud(pc.points);

      // The slice of the point cloud that will be displayed.
      let slice = pc.sliceYRay(y, z, -angle * Math.PI / 180, divergence * Math.PI / 180);

      // Bin the points from the slice. This is done to locate the highest
      // point in each bin, for both display and analysis.
      slice.points.forEach(pt => {
        let yy = parseInt(pt.y / binSize) * binSize;
        if(!bins.has(yy) || pt.z > bins.get(yy).z)
          bins.set(yy, pt.clone());
        accum.addPoint(pt.clone());
      });

      // Get the convex hull of the accumulated points.
      let hull = accum.getHull(binSize);

      // A new point cloud from the points in the bins. Scale for display.
      let heights = new PointCloud(Array.from(bins.values()));

      // Get the spline throught the binned heights.
      let spline = getCRSplines(hull.points, alpha);

      let tslice = hull.sliceSeg(y, 4);
      let traj = null;
      if(tslice.length == 4) {
        const t0 = y;
        const t1 = crTJ(t0, tslice[0], tslice[1], alpha);
        const t2 = crTJ(t1, tslice[1], tslice[2], alpha);
        let t = t1 + (t2 - t1) / 2;//(y - tslice[1].y);// / (tslice[2].y - tslice[1].y);
        traj = new PointCloud([catmullRomSplineT(t, tslice[0], tslice[1], tslice[2], tslice[3], alpha)]);
      }

      // Scale point clouds for display.
      heights.scale(screen, bounds);
      slice.scale(screen, bounds);
      spc.scale(screen, bounds);
      uavpc.scale(screen, bounds);
      hull.scale(screen, bounds);
      Point.scale(spline, screen, bounds);
      if(traj)
        traj.scale(screen, bounds);

      ctx.clearRect(0, 0, screen.length, screen.height);

      // Draw the whole cloud lightly.
      ctx.fillStyle = '#dddddd';
      spc.points.forEach(pt => {
        ctx.fillRect(pt.y - 2, screen.zmax - pt.z - 2, 4, 4);
      });

      // Draw the slice points.
      ctx.fillStyle = stylePoint;
      slice.points.forEach(pt => {
        ctx.fillRect(pt.y - 2, screen.zmax - pt.z - 2, 4, 4);
      });

      // Draw the binned points.
      ctx.fillStyle = 'red';
      heights.points.forEach(pt => {
        ctx.fillRect(pt.y - 2, screen.zmax - pt.z - 2, 4, 4);
      });

      ctx.fillStyle = 'green';
      hull.points.forEach(pt => {
        ctx.fillRect(pt.y - 2, screen.zmax - pt.z - 2, 4, 4);
      });

      // Draw the UAV.
      let uavpt = uavpc.points[0];
      ctx.fillStyle = 'black';
      ctx.fillRect(uavpt.y - 3, screen.zmax - uavpt.z - 3, 6, 6);

      // Draw the height spline
      if(spline.length) {
        ctx.lineStyle = '1px solid blue';
        ctx.beginPath();
        ctx.moveTo(spline[0].y, spline[0].z);
        for(let i = 1; i < spline.length; ++i)
          ctx.lineTo(spline[i].y, screen.zmax - spline[i].z);
        ctx.stroke();
      }

      if(traj) {
        ctx.lineStyle = '1px solid fuscia';
        ctx.fillStyle = 'fuscia';
        ctx.fillRect(traj.points[0].y - 3, screen.zmax - traj.points[0].z - 3, 6, 6);
      }

      if(running)
        requestAnimationFrame(animate);
    }

    function start(evt) {
      evt.preventDefault();
      update();
      startTime = null;
      pcframe = null;
      running = true;
      bins.clear();
      requestAnimationFrame(animate);
    }

    function stop(evt) {
      evt.preventDefault();
      running = false;
    }

    function init() {
      let w = document.body.clientWidth;
      let h = 600;
      let canv = document.querySelector('#canv');
      canv.width = w;
      canv.height = h;
      let sel = document.querySelector('#filename');
      sel.add(new Option('', '- Select One -'));
      let i = 0;
      filenames.forEach(f => {
        sel.add(new Option(f, ++i));
      });
      sel.addEventListener('change', loadFile);
    }

  </script>

</head>

<body onload="init();">
  <form>
    <table>
      <tr><td><label for="filename">File</label></td><td><select name="filename" id="filename"></select> <span id="loading"></span></td></tr>
      <tr><td><label for="speed">Speed (m/s)</label></td><td><input name="speed" id="speed" value="4" /></td></tr>
      <tr><td><label for="angle">Beam Angle (Down)</label></td><td><input id="angle" name="angle" onchange="update(event);" value="25" /></td></tr>
      <tr><td><label for="divergence">Beam Divergence</label></td><td><input id="divergence" name="divergence" onchange="update(event);" value="1" /></td></tr>
      <tr><td><label for="alpha">Alpha</label></td><td><input id="alpha" name="divergence" onchange="update(event);" value="0.75" /></td></tr>
      <tr><td><label for="altitude">Altitude</label></td><td><input id="altitude" name="altitude" onchange="update(event);" value="100" /></td></tr>
      <tr><td><label for="binSize">Bin Size</label></td><td><input id="binSize" name="binSize" onchange="update(event);" value="10" /></td></tr>
      <tr><td colspan="2"><button onclick="start(event);">Start</button> <button onclick="stop(event);">Stop</button></td></tr>
    </table>
  </form>
  <div style="border:1px solid #ccc">
    <canvas id="canv" width="2000" height="600" style="background-color: white"></canvas>
  </div>
</body>
</html>