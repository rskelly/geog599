<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Splines</title>
  <meta name="description" content="Splines">
  <meta name="author" content="rob">

  <!--<link rel="stylesheet" href="css/styles.css?v=1.0">-->

  <script>

    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      times(s) {
        return new Point(this.x * s, this.y * s);
      }
      plus(p) {
        return new Point(this.x + p.x, this.y + p.y);
      }
    }

    const _p = Math.pow;
    const _s = Math.sqrt;

    function tj(ti, pi, pj, alpha) {
      let a = _p(pj.x - pi.x, 2.0) + _p(pj.y - pi.y, 2.0);
      let b = _s(a);
      let c = _p(b, alpha);
      return ti + c;
    }

    function catmullRomSpline(p0, p1, p2, p3, alpha = 0.5, npoints = 10) {

      t0 = 0.0;
      t1 = tj(t0, p0, p1, alpha);
      t2 = tj(t1, p1, p2, alpha);
      t3 = tj(t2, p2, p3, alpha);

      let out = []

      for(let t = t1; t < t2; t += (t2 - t1) / npoints) {

        let a1 = p0.times((t1 - t) / (t1 - t0)).plus(p1.times((t - t0) / (t1 - t0)));
        let a2 = p1.times((t2 - t) / (t2 - t1)).plus(p2.times((t - t1) / (t2 - t1)));
        let a3 = p2.times((t3 - t) / (t3 - t2)).plus(p3.times((t - t2) / (t3 - t2)));
        let b1 = a1.times((t2 - t) / (t2 - t0)).plus(a2.times((t - t0) / (t2 - t0)));
        let b2 = a2.times((t3 - t) / (t3 - t1)).plus(a3.times((t - t1) / (t3 - t1)));
        let c  = b1.times((t2 - t) / (t2 - t1)).plus(b2.times((t - t1) / (t2 - t1)));

        out.push(c);

      }      

      return out;
    }

    function catmullRomChain(points, alpha = 0.95, npoints = 10) {
      let out = [];
      for(let i = 0; i < points.length - 3; ++i)
        Array.prototype.push.apply(out, catmullRomSpline(points[i], points[i + 1], points[i + 2], points[i + 3], alpha, npoints));
      return out;
    }

  	function rpt(xrange, yrange, x = 0.0, y = 0.0) {
		  return [x + Math.random() * xrange, y + (Math.random() - 0.5) * 2 * yrange];
  	}

  	function genPts() {
  		let pts = [];
  		let pt = [0, 500];
  		for(let i = 0; i < 100; ++i) {
  			pt = rpt(50, 100, i * 100, pt[1]);
  			for(let j = 0; j < 10; ++j)
  				pts.push(rpt(150, 30, pt[0], pt[1]));
  		}
  		return pts;
  	}

  	function p3(t) {
  		return t*t*t;
  	}

  	function p2(t) {
  		return t*t;
  	}

  	function spline(t, p0, p1, m0, m1) {
  		return (2 * p3(t) - 3 * p2(t) + 1) * p0 + (p3(t) - 2 * p2(t) + t) * m0 + (-2 * p3(t) + 3 * p2(t)) * p1 + (p3(t) - p2(t)) * m1;
  	}

  	function draw(pts, style) {
  		let ctx = document.querySelector('#canv').getContext('2d');
  		ctx.fillStyle = style;
  		pts.forEach(pt => {
			 ctx.fillRect(pt[0] - 2, pt[1] - 2, 4, 4);
  		});
  	}

    function drawLines(pts, style) {
      let ctx = document.querySelector('#canv').getContext('2d');
      ctx.beginPath();
      ctx.strokeStyle = style;
      ctx.moveTo(pts[0][0], pts[0][1]);
      for(let i = 1; i < pts.length; ++i)
        ctx.lineTo(pts[i][0], pts[i][1]);
      ctx.stroke();
    }

  	function drawSlopes(slopes, style) {
  		let ctx = document.querySelector('#canv').getContext('2d');
      ctx.beginPath();
  		ctx.strokeStyle = style;
  		slopes.forEach(item => {
  			let pt = item[0];
  			let slope = item[1];
  			let x0 = pt[0] - 10.0;
  			let x1 = x0 + 20.0;
  			let y0 = pt[1] - slope * 10.0;
  			let y1 = pt[1] + slope * 10.0;
  			ctx.moveTo(x0, y0);
  			ctx.lineTo(x1, y1);
  			ctx.stroke();
  		});
  	}

  	function drawSplines(pts, slopes, style) {
  		let ctx = document.querySelector('#canv').getContext('2d');
      ctx.beginPath();
  		ctx.strokeStyle = style;
  		let m = 0.0;
  		for(let i = 0; i < pts.length - 2; ++i) {
  			let a = pts[i];
  			let b = pts[i + 1];
  			let m0 = m;
  			let m1 = -slopes[i][1];
  			let p0 = a[1];
  			let p1 = b[1];
  			for(let j = 0; j <= 10; ++j) {
  				let x = a[0] + (b[0] - a[0]) / 10.0 * j;
  				let y = spline(j / 10.0, p0, p1, m0, m1);
  				if(j == 0) {
  					ctx.moveTo(x, y);
  				} else {
  					ctx.lineTo(x, y);
  				}
  			}
			ctx.stroke();
  			m = m1;
  		}
  	}

    function drawCMSplines(pts, offset, style) {
      let ctx = document.querySelector('#canv').getContext('2d');
      ctx.beginPath();
      ctx.strokeStyle = style;
      let cmpts = catmullRomChain(pts);
      console.log(cmpts);
      let pt = cmpts[0];
      ctx.moveTo(pt.x, pt.y);
      for(let i = 1; i < cmpts.length; ++i) {
        pt = cmpts[i];
        ctx.lineTo(pt.x, pt.y + offset);
      }
      ctx.stroke();
    }

    const MAX = 1;
    const MEAN = 2;

  	function genClust(pts, num, type = MAX) {
  		let minx = 99999999.9;
  		let maxx = -99999999.9;
  		let miny = 99999999.9;
  		let maxy = -99999999.9;
  		pts.forEach(pt => {
  			if(minx > pt[0]) minx = pt[0];
  			if(miny > pt[1]) miny = pt[1];
  			if(maxx < pt[0]) maxx = pt[0];
  			if(maxy < pt[1]) maxy = pt[1];
  		});
  		let w = (maxx - minx) / num;
  		let result = new Array(num);
  		pts.forEach(pt => {
  			let i = parseInt((pt[0] - minx) / (maxx - minx) * num);
  			if(!result[i]) result[i] = [];
  			result[i].push(pt);
  		});
      switch(type) {
      case MEAN:
        for(let i = 0; i < num; ++i) {
    			let cnt = result[i].length;
    			if(cnt > 0) {
      			let xsum = 0.0;
      			let ysum = 0.0;
      			for(let j = 0; j < cnt; ++j) {
      				xsum += result[i][j][0];
      				ysum += result[i][j][1];
      			}
      			result[i] = [xsum / cnt, ysum / cnt]
          }
        }
        break;
      case MAX:
        for(let i = 0; i < num; ++i) {
          let cnt = result[i].length;
          let max = null;
          let ymax = 99999999.0;
          for(let j = 0; j < cnt; ++j) {
            if(result[i][j][1] < ymax) {
              ymax = result[i][j][1];
              max = result[i][j];
            }
          }
          result[i] = max;
        }
        break;
      default:
        throw new Error('Unknown type ' + type);
      }
    	return result;
  	}

    function _cross(p0, p1, p) {
      return (p0[0] - p[0]) * (p1[1] - p[1]) - (p0[1] - p[1]) * (p1[0] - p[0]);
    }

    function _sort(p0, p1) {
      return p0[0] == p1[0] ? p0[1] > p1[1] : p0[0] > p1[0];
    }

    function _length(p0, p1) {
      return _p(p0[0] - p1[0], 2) + 0; //_p(p0[1] - p1[1], 2);
    }

    function getHull(pts_, alpha) {
      alpha = alpha * alpha;
      let pts = pts_.sort(_sort);
      let hull = [pts[0], pts[1]];
      for(let i = 2; i < pts.length; ++i) {
        // The _length call limits the range of the search for a convex point; causes an alpha-like surface.
        while(hull.length >= 2 && _cross(hull[hull.length - 2], hull[hull.length - 1], pts[i]) <= 0 && _length(hull[hull.length - 2], pts[i]) < alpha)
          hull.pop();
        hull.push(pts[i]);
      }
      return hull;
    }

  	function getSlopes(pts) {
  		let slopes = [];
  		for(let i = 1; i < pts.length - 1; ++i) {
  			let a = pts[i - 1];
  			let b = pts[i];
  			let c = pts[i + 1];
  			let sca = (c[1] - a[1]) / (c[0] - a[0]);
  			slopes.push([b, sca])
  		}
  		return slopes;
  	}

  	function run() {
  		let pts = genPts();
  		draw(pts, '#aaaaff');
      let hull = getHull(pts, 100);
      draw(hull, 'red');
      drawLines(hull, 'red');
      for(let i = 0; i < hull.length; ++i)
        hull[i] = new Point(hull[i][0], hull[i][1]);
      //drawHull(hull)
  		//drawCMSplines(hull, 0, 'green');
      drawCMSplines(hull, -20, 'blue');
  	}
  </script>

</head>

<body onload="run();" style="background-color: black">
  <canvas id="canv" width="2400" height="1200" style="background-color: white"></canvas>
</body>
</html>