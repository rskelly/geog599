<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Splines</title>
  <meta name="description" content="Splines">
  <meta name="author" content="rob">

  <!--<link rel="stylesheet" href="css/styles.css?v=1.0">-->

  <script>

    const _p = Math.pow;
    const _s = Math.sqrt;
    const _min = Math.min;
    const _max = Math.max;

    function _p3(t) {
      return t*t*t;
    }

    function _p2(t) {
      return t*t;
    }

    const defaultMaxBounds = [Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE];
    let pointCloud = null; // The loaded points from a text file.
    let pointBounds = null; // min/max x, y, z

    class Point {
      constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }
      times(s) {
        return new Point(this.x * s, this.y * s, this.z * s);
      }
      plus(p) {
        return new Point(this.x + p.x, this.y + p.y, this.z + p.z);
      }
      clone() {
        return new Point(this.x, this.y, this.z);
      }
      equals(p) {
        return this.x == p.x && this.y == p.y && this.z == p.z;
      }
    }

    function tj(ti, pi, pj, alpha) {
      let a = _p(pj.x - pi.x, 2.0) + _p(pj.z - pi.z, 2.0);
      let b = _s(a);
      let c = _p(b, alpha);
      return ti + c;
    }

    function catmullRomSpline(p0, p1, p2, p3, alpha = 0.5, npoints = 10) {

      t0 = 0.0;
      t1 = tj(t0, p0, p1, alpha);
      t2 = tj(t1, p1, p2, alpha);
      t3 = tj(t2, p2, p3, alpha);

      let out = []

      for(let t = t1; t < t2; t += (t2 - t1) / npoints) {

        let a1 = p0.times((t1 - t) / (t1 - t0)).plus(p1.times((t - t0) / (t1 - t0)));
        let a2 = p1.times((t2 - t) / (t2 - t1)).plus(p2.times((t - t1) / (t2 - t1)));
        let a3 = p2.times((t3 - t) / (t3 - t2)).plus(p3.times((t - t2) / (t3 - t2)));
        let b1 = a1.times((t2 - t) / (t2 - t0)).plus(a2.times((t - t0) / (t2 - t0)));
        let b2 = a2.times((t3 - t) / (t3 - t1)).plus(a3.times((t - t1) / (t3 - t1)));
        let c  = b1.times((t2 - t) / (t2 - t1)).plus(b2.times((t - t1) / (t2 - t1)));

        out.push(c);

      }      

      return out;
    }

    function getCRSplines(points, alpha = 0.95, npoints = 10) {
      let out = [];
      for(let i = 0; i < points.length - 3; ++i)
        Array.prototype.push.apply(out, catmullRomSpline(points[i], points[i + 1], points[i + 2], points[i + 3], alpha, npoints));
      return out;
    }

  	function draw(pts, style) {
  		let ctx = document.querySelector('#canv').getContext('2d');
  		ctx.fillStyle = style;
  		pts.forEach(pt => {
			 ctx.fillRect(pt.x - 2, pt.z - 2, 4, 4);
  		});
  	}

    function drawSegs(segs, style) {
      let ctx = document.querySelector('#canv').getContext('2d');
      ctx.strokeStyle = style;
      segs.forEach(seg => {
        ctx.beginPath();
        ctx.moveTo(seg[0].x, seg[0].z);
        ctx.lineTo(seg[1].x, seg[1].z);
        ctx.stroke();
      });
    }

    function drawLines(pts, style, offset = 0.0) {
      let ctx = document.querySelector('#canv').getContext('2d');
      ctx.beginPath();
      ctx.strokeStyle = style;
      ctx.moveTo(pts[0].x, pts[0].z);
      for(let i = 1; i < pts.length; ++i)
        ctx.lineTo(pts[i].x, pts[i].z + offset);
      ctx.stroke();
    }

    // Tests which side of the line, described by p0 and p1, p is on.
    function _cross(p0, p1, p) {
      return (p0.x - p.x) * (p1.z - p.z) - (p0.z - p.z) * (p1.x - p.x);
    }

    // Sort the points on x first, then y.
    function _sort(p0, p1) {
      return p0.x == p1.x ? p0.z > p1.z : p0.x > p1.x;
    }

    // Return the squared distance between the points, but only in x.
    function _length(p0, p1) {
      return _p(p0.x - p1.x, 2) + 0; //_p(p0.z - p1.z, 2);
    }

    // Finds the maximum z within winsize Cartesian distance of the point at idx.
    function _inwindow(pts, idx, winsize) {
      let z = pts[idx].z;
      let out = idx;
      for(let i = idx + 1; i < pts.length; ++i) {
        if(_length(pts[idx], pts[i]) <= winsize) {
          if(pts[i].z > z)
            out = i;
        } else {
          break;
        }
      }
      for(let i = idx - 1; i >= 0; --i) {
        if(_length(pts[idx], pts[i]) <= winsize) {
          if(pts[i].z > z)
            out = i;
        } else {
          break;
        }
      }
      return pts[out];
    }

    function getHull(pts_, alpha) {
      alpha *= alpha;
      winsize *= winsize;
      let pts = pts_.sort(_sort);
      let hull = [pts[0], pts[1]];
      for(let i = 2; i < pts.length; ++i) {
        // The _length call limits the range of the search for a convex point; causes an alpha-like surface.
        while(hull.length >= 2 && _cross(hull[hull.length - 2], hull[hull.length - 1], pts[i]) >= 0 && (alpha <= 0 || _length(hull[hull.length - 2], pts[i]) <= alpha))
          hull.pop();
        hull.push(pts[i]);
      }
      return hull;
    }

    function getNormal2(pt0, pt1, length = 10) {
      let dx = pt1.x - pt0.x;
      let dz = pt1.z - pt0.z;
      let h = _s(_p2(dx) + _p2(dz));
      let p = length / h;
      let pt2 = new Point(pt0.x + dx / 2.0, 0, pt0.z + dz / 2.0);
      let pt3 = new Point(pt2.x + p * dz, 0, pt2.z + p * -dx);
      return [pt2, pt3];
    }

    function getNormal3(pt0, pt1, pt2, length = 10) {
      // These two angles are on the underside, relative to vertical.
      let a0 = Math.atan2(pt0.z - pt1.z, pt0.x - pt1.x);  
      let a1 = Math.atan2(pt2.z - pt1.z, pt2.x - pt1.x);
      let a = a0 - ((a0 - a1) / 2.0);
      while(a < 0.0) a += Math.PI * 2.0;
      while(a > Math.PI * 2.0) a -= Math.PI * 2.0;
      if(a > Math.PI) a -= Math.PI;
      let pt = new Point(pt1.x + Math.cos(a) * length, 0, pt1.z + Math.sin(a) * length);
      return [pt1, pt];
    }

    function getSlope(pt0, pt1) {
      return (pt1.z - pt0.z) / (pt1.x - pt0.x);
    }

    function filterHull(hull) {
      // Remove clusters from the hull. Take the highest elevation in the cluster and replace the remaining
      // null nodes' z value.
      let hull0 = [hull[0].clone()];
      for(let i = 1; i < hull.length; ++i) {
        let m = -1 / getSlope(hull[i - 1], hull[i])
        console.log(m, Math.abs(m));
        if(Math.abs(m) > 1)
          hull0.push(hull[i - 1].z > hull[i].z ? hull[i - 1] : hull[i]);
      }
      if(!hull0[0].equals(hull[hull.length - 1]))
        hull0.push(hull[hull.length - 1]);
      return hull0;
    }

    let alpha = 25;
    let winsize = 10;

  	function run() {

      let canv = document.querySelector('#canv'); 
      let ctx = canv.getContext('2d');
      ctx.clearRect(0, 0, canv.width, canv.height);

      let colors = ['orange', 'red', 'blue', 'green', 'yellow', 'fuscia', 'cyan', 'purple'];

      transformPointCloud();

      // Get the upper alpha shape of the point cloud.
      let hull = getHull(pointCloud, alpha);

      // Get the perpendiculars as a new point set, with the upper points of the perps.
      let perps = [];
      for(let i = 0; i < hull.length - 1; ++i)
        perps.push(scalePointCloud(getNormal2(hull[i], hull[i + 1], 20)));
      for(let i = 0; i < hull.length - 2; ++i)
        perps.push(scalePointCloud(getNormal3(hull[i], hull[i + 1], hull[i + 2], 20)));

      // Get the alpha hull of the perpendicular end points.
      let perphull = getHull(perps.map(perp => { return perp[1]; }), alpha);

      // Get the splines from the perp hull.
      let spline = getCRSplines(perphull);

      // Scaled hull points.
      let hs = scalePointCloud(hull);

      // Scaled perps
      let ps = [];
      for(let i = 0; i < perps.length; ++i)
        ps.push(scalePointCloud(perps[i]));

      // Scale the spline
      let ss = scalePointCloud(spline);

      // Scale point cloud.
      let pc = scalePointCloud(pointCloud);

      // Draw point cloud
      draw(pc, '#aaffaa');

      // Draw perp segments.
      drawSegs(ps, colors[0]);
      //draw(hs, colors[1]);
      //drawLines(hs, colors[1]);
      //drawLines(ss, colors[2], -20);
      
  	}

    function update(evt) {
      if(evt)
        evt.preventDefault();
      alpha = parseFloat(document.querySelector('#alpha').value);
      winsize = parseFloat(document.querySelector('#winsize').value);
      run();
    }

    /**
     * Transforms the 3D Cartesian point cloud so that, instead of y/x coordinates,
     * we have y=0 and x= the range from an origin at the minimum corner of the cloud.
     */
    function transformPointCloud() {
      let x = pointBounds[0];
      let y = pointBounds[2];
      let maxD = 0;
      for(let i = 0; i < pointCloud.length; ++i) {
        let pt = pointCloud[i];
        let d = _s(_p(pt.x - x, 2) + _p(pt.y - y, 2));
        pt.x = d;
        pt.y = 0;
        if(d > maxD) maxD = d;
      }
      pointBounds[0] = 0.0;
      pointBounds[1] = maxD;
      pointBounds[2] = 0.0;
      pointBounds[3] = 0.0;
    }

    /**
     * Scales point cloud to screen coords.
     */
    function scalePointCloud(pc) {
      let canv = document.querySelector('#canv');
      let cw = canv.width;
      let ch = canv.height;
      let dx = pointBounds[1] - pointBounds[0];
      let dz = pointBounds[5] - pointBounds[4];
      let scale = _min(cw / dx, ch / dz);
      let scaled = [];
      for(let i = 0; i < pc.length; ++i) {
        let pt = pc[i].clone();;
        pt.x = (pt.x - pointBounds[0]) * scale;
        pt.z = (ch - 20) - (pt.z - pointBounds[4]) * scale;
        scaled.push(pt);
      }
      return scaled;
    }

    function loadFile(evt) {
      evt.preventDefault();
      document.querySelector('#loading').innerHTML = 'Loading..';
      pointCloud = [];
      pointBounds = [];
      Array.prototype.push.apply(pointBounds, defaultMaxBounds);
      let file = document.querySelector('#filename').selectedOptions[0].text;
      let reader = new XMLHttpRequest();
      reader.overrideMimeType('text/plain');
      reader.open('GET', file);
      reader.addEventListener('load', evt => {
        if(reader.readyState == 4) {
          let rows = reader.responseText.split(/\n/);
          rows.forEach(row => {
            row = row.split(',').slice(0, 3).map(parseFloat);
            let pt = new Point(row[0], row[1], row[2]);
            if(isNaN(pt.x)) return;
            pointCloud.push(pt);
            pointBounds[0] = _min(pt.x, pointBounds[0]);
            pointBounds[1] = _max(pt.x, pointBounds[1]);
            pointBounds[2] = _min(pt.y, pointBounds[2]);
            pointBounds[3] = _max(pt.y, pointBounds[3]);
            pointBounds[4] = _min(pt.z, pointBounds[4]);
            pointBounds[5] = _max(pt.z, pointBounds[5]);
          });
          document.querySelector('#loading').innerHTML = '';
          update();
        }
      });
      reader.send();
    }

    const filenames = ['mt_doug_1.txt', 'mt_doug_2.txt', 'mt_doug_3.txt'];

    function init() {
      let w = document.body.clientWidth;
      let h = 400;//document.innerHeight;
      let canv = document.querySelector('#canv');
      canv.width = w;
      canv.height = h;
      let sel = document.querySelector('#filename');
      sel.add(new Option('', '- Select One -'));
      let i = 0;
      filenames.forEach(f => {
        sel.add(new Option(f, ++i));
      });
      sel.addEventListener('change', loadFile);
    }

  </script>

</head>

<body onload="init();">
  <form>
    <table>
      <tr><td><label for="filename">File</label></td><td><select name="filename" id="filename"></select> <span id="loading"></span></td></tr>
      <tr><td><label for="alpha">Alpha</label></td><td><input id="alpha" name="alpha" onchange="update(event);" value="25" /></td></tr>
      <tr><td><label for="winsize">Window Size</label></td><td><input id="winsize" name="winsize" onchange="update(event);" value="10" /></td></tr>
      <!--<tr><td colspan="2"><button onclick="loadFile(event);">Load</button></td></tr>-->
    </table>
  </form>
  <div style="border:1px solid #ccc">
    <canvas id="canv" width="2000" height="600" style="background-color: white"></canvas>
  </div>
</body>
</html>