\startfirstchapter{Methods}
\label{chapter:Methods}

\section{Equipment}

To prove the concept, it was necessary to equip a UAV with a computer, scanning laser rangefinder and the necessary peripherals and connections.

\subsection{Aircraft}

The platform selected for the experiment was a DJI Matrice 600 hexacopter. Some specifications for the vehicle are given in table \ref{table:djispecs}.

\begin{table}
\begin{center}
\begin{tabular}{ l r }
\hline
Vehicle weight (TB47S batteries) & $\SI{9.1}\kg$ \\ 
Vehicle weight (TB48S batteries) & $\SI{9.6}\kg$ \\
Maximum vehicle weight & $\SI{15.1}\kg$ \\
Maximum pitch angle & $\ang{25}$ \\
Maximum pitch velocity & $\SI{300}{\degree\per\second}$ \\
Maximum yaw velocity & $\SI{150}{\degree\per\second}$ \\
Maximum ascent velocity & $\SI{5}{\metre\per\second}$ \\
Maximum descent velocity & $\SI{3}{\metre\per\second}$ \\
Maximum horizontal velocity & $\SI{18}{\metre\per\second}$ \\
Maximum wind velocity & $\SI{8}{\metre\per\second}$ \\
Maximum thrust & $\SI{5100}{\g}$ \\
\hline
\end{tabular}
\end{center}
\caption{DJI Matrice 600 Specifications \cite{DJI2017}.}
\label{table:djispecs}
\end{table}

These constraints may not correspond to the absolute physical limits on vehicle performance, but they do provide a useful guide to the limits that may be imposed by the flight control API, and from these quantities, the dynamic limits of the platform (e.g., maximum thrust) may be inferred.

The nominal maximum thrust, $T_n$, generated by the DJI6100/DJI2170 motor/propeller combination is given in $g$ of pulling force per rotor. The propulsive forces of the six rotors cannot be summed directly because their axes are not aligned. However, it is a simple matter to decompose the thrust vector of each into its $T_x$ and $T_z$, components ($T_z$ is vertical; $T_y$ is not required) and sum the $T_z$ components. The $T_x$ components can be ignored because, being radially opposed, they cancel out.

Measured from CAD drawings supplied by DJI, each arm of the hexacopter is inclined upwards from horizontal by $8\deg$, or $0.139643114$ radians. The $T_z$ component is then,

\begin{equation}
\begin{split}
T_z &= sin(\theta) * T_n \\
T_z &= sin(0.139643114) * 5.1 \\
T_z &= 0.990265734 * 5.1 \\
T_z &\approx \SI{5.050}{\kg} % 5.050355244.
\end{split}
\end{equation}

This gives a total maximum thrust $T_{max}$ of,

\begin{equation}
\begin{split}
T_{max} &= 6 * T_z \\
T_{max} &\approx \SI{30.302}{\kg}.
\end{split}
\end{equation} 

We wish to represent the maximum available thrust as a force, $F_t$, in Newtons. Assuming a vertical orientation of the thrust vector and the acceleration of gravity as $g$, 

\begin{equation}
\begin{split}
F_t &= T_{max} * g \\
F_t &= T_{max} * 9.08665 \\
F_t &\approx \SI{297.162}{\N}
\end{split}
\end{equation}

At the maximum vehicle weight of $M_v = \SI{15.1}{\kg}$, this gives a maximum vertical linear acceleration of,

\begin{equation}
\begin{split}
a &= (F_t - F_g - F_d) / M_v \\
a &= (297.162397521 - (9.80665 * 15.1) - 0) / 15.1 \\
a &\approx \SI{9.873}{\m\s^{-2}}, %9.872978975
\end{split}
\end{equation}

where $F_g$ is the force of gravity and $F_d$ is the force of drag -- zero, under the assumption that vertical accelerations begin during level flight.

With the TB47S battery set, the hover time (at $\SI{10}{\metre}$ above sea level and no wind) is given as $\SI{35}{\minute}$ with no load and $\SI{16}{\minute}$ with the maximum $\SI{6}{\kg}$ payload. With the TB48S batteries, the Matrice can hover for $\SI{40}{\minute}$ with no load and $\SI{18}{\minute}$ with a $\SI{5.5}{\kg}$ payload. With these short flight times, especially with the additional weight of the terrain-following system, it is clear that optimizing for battery life is justified \cite{DJI2017}.

\subsection{Computer}

A single Raspberry Pi 3 B+ multi-tasking computer is used to receive inputs from the sensors, produce the point cloud, calculate the and optimize the trajectory, drive the actuators and communicate with the Matrice's control API. The computer runs the standard Raspbian Jessie (Debian Linux) operating system with a custom kernel compiled with the \texttt{PREEMPT\_RT} patch (v4.14.y-rt). All software for this project is written in the C++ language.

\subsection{Sensors}

The primary purpose of the sensor package is twofold: first, to generate a point cloud forward of the vehicle as it flies along its trajectory; second, to measure, in real time, its current altitude above the surface. 

The point cloud is generated by a LightWare Optoelectronics SF30/C laser rangefinder. Specifications for this device are given in table \ref{table:lwsf30cspecs}. The Raspberry Pi receives range data directly from SF30/C via RS232 serial communication.

\begin{table}
\begin{center}
\begin{tabular}{l r}
\hline
Maximum range & $> \SI{100}{\metre}$ \\
Maximum pulse frequency & $> \SI{18}{\kHz}$ \\
Weight & $\SI{35}{\g}$ \\
\hline
\end{tabular}
\end{center}
\caption{LightWare SF30/C rangefinder specifications \cite{LightWare2016}.}
\label{table:lwsf30cspecs}
\end{table}

The SF30/C is mounted on a generic (unbranded) P3022 Hall-effect analog angular encoder, which serves as both the bearing for the oscillating laser, and as a means of measuring its current angle. The encoder transmits a voltage relative to the input voltage in proportion to the angle of the shaft, from which the angle in radians can be computed. Specifications for the encoder are given in table \ref{table:encoderspecs}. As the output of the encoder is analog, and a digital reading is required, the voltage is sent to a Texas Instruments ADS1115 analog-to-digital converter (ADC), mounted on a breakout board manufactured by the Adafruit company. The Raspberry Pi communicates with the ADC via the I2C protocol.

\begin{table}
\begin{center}
\begin{tabular}{l r}
\hline
Resolution & 12 bits ($\SI{360}{\degree} / 4096 \approx \SI{0.088}{\degree}$ \\
Linearity & $0.3\percent$ \\
Operating voltage & $\SI{5}{\volt} \pm \SI{10}{\percent}$ \\
Output voltage & $\SIrange{0}{5}{\volt}$ \\
Operating current & $< \SI{16}{\milli\ampere}$  \\ 
Weight & $\SI{25}{\gram}$ \\
\hline
\end{tabular}
\end{center}
\caption{P3022 Hall-effect encoder specifications.}
\label{table:encoderspecs}
\end{table}

The shaft of the encoder is driven using a four-bar linkage connected to a generic $\SIrange{2.5}{7.5}{\volt}$ geared, brushless direct current (DC) micromotor. The rotational speed of the motor (and thus the scan frequency of the laser) is governed by pulse width modulation (PWM), which can be modified through the flight control computer, and the degree of sweep is governed by the length of the linkage, which must be adjusted manually. 

The PWM signal is generated by the Raspberry Pi via its built-in GPIO pins and sent to a Texas Instruments DRV8835 dual H-bridge motor driver. This is mounted on a breakout board manufactured by Pololu Corporation. The DRV8835 both provides external power to the motor and regulates its speed using the PWM signal.

The nadir-aligned laser is a LightWare Optoelectronics SF11/C laser rangefinder, which is similar to the SF30/C, save for a higher nominal range of $\SI{120}{\metre}$ and a maximum pulse rate of $\SI{20}{pulses\per\second}$  \cite{LightWareOptoelectronics2018}. Though the range of the nadir-aligned laser is counterintuitively larger than that of the forward laser, its pulse rate is much lower -- suitable for altitude measurement but not for point cloud generation. Unlike the SF30/C, the SF11/C communicates with the Raspberry Pi via the I2C protocol, as there is only one serial port, and it is required for the high volume of data produced by the SF30/C. In any case, the SF30/C, being an older model does not have I2C capability.

The encoder and nadir-facing laser are rigidly mounted on an aluminum carriage which rotates on the vehicle-aligned y-axis. A stepper motor with a screw-type linear actuator drives the carriage on this axis, allowing it to maintain its orientation. This maintains the alignment of both lasers as the vehicle pitches. The actuator is driven by the Raspberry Pi, through another DRV8835.

A miniature inertial measurement unit (IMU), manufactured by Pololu, is used to measure the deviation from vertical of the sensor carriage. The IMU consists of an STMicroelectronics LSM6DS33 accelerometer and gyroscope, as well as a thermometer and magnetometer, which are not used. The output of the IMU is used by the computer to drive the linear actuator to correct the orientation of the carriage. The Raspberry Pi communicates with the IMU via the I2C protocol.

The two motor drivers and the ADC are mounted on a circuit board custom-manufactured by MacroFab LLC. This board has numerous Molex PicoBlade connectors for connecting the board to the Raspberry Pi, and to the lasers, motors and IMU, which are each mounted independently.





